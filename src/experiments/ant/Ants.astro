<canvas id="app" width="600" height="600"></canvas>

<style lang="scss" is:global>
    #app {
        border-radius: 300px;
        pointer-events: none;
    }
</style>

<script>
import { Application, autoDetectRenderer, CanvasSource, Color, Container, Graphics, Particle, ParticleContainer, Sprite, Texture, type IParticle } from 'pixi.js';
import { dist, lerp, PI, random, TWO_PI } from './utils'
import { Pheremone, type PheremoneData } from './pheremones'
import { FoodMap } from './food';

// 60 ticks per second
let start = new Date().getTime()
const simulationSpeed = 60

const canvasSize = 600;
const pheremonesSize = 60;
const antCount = 20_000

const antSpeed = 1.75;
const antChangeDirectionChance = 0.01;
const antPheremoneDirectionMinStrength = 0.1;
const antPheremoneDirectionMaxStrength = 0.3;
const antColor = new Color('#00000088');

const foodDetectionRadius = 40;
// How many times can one pixel be eaten
const foodStrength = 1;
const foodColor = new Color('rgb(117, 162, 103)')
const endSimulationFoodThreshold = 1000

let remainingFood = 999999

const renderer = await autoDetectRenderer({
  preference: 'webgpu',
});

const app = new Application();
app.renderer = renderer;

await app.init({
    backgroundAlpha: 0,
    view: document.getElementById('app') as HTMLCanvasElement,
    width: canvasSize,
    height: canvasSize,
});

// Create and add a container to the stage
const container = new ParticleContainer();

app.stage.addChild(container);

type Ant = {
    x: number;
    y: number;
    angle: number;
    hasFood: boolean;
    nearNest: boolean;
    nearFood: boolean;
    sprite: IParticle;
}

const homePheremones = new Pheremone(pheremonesSize, pheremonesSize, pheremonesSize / canvasSize);

const foodPheremones = new Pheremone(pheremonesSize, pheremonesSize, pheremonesSize / canvasSize);

const foodTexture = new FoodMap(canvasSize, canvasSize)

const foodGraphics = new Graphics().rect(0, 0, canvasSize, canvasSize).fill(foodTexture.image)
app.stage.addChild(foodGraphics);

const nest = {
    x: 300,
    y: 500,
    radius: 50
}

const antTextureSource = new CanvasSource({
    height: 1,
    width: 1,
    format: 'rgba8unorm',
    scaleMode: 'nearest'
})
antTextureSource.context2D.fillStyle = antColor.toHex()
antTextureSource.context2D.fillRect(0, 0, 1, 1);
const antTexture = new Texture({ source: antTextureSource })

const ants: Ant[] = []

// Initialize ants
for (let i = 0; i < antCount; i++) {

    // Generate a random position near the nest
    const angle = random(TWO_PI);
    const distance = random(0, nest.radius);
    
    const x = nest.x + Math.cos(angle) * distance;
    const y = nest.y + Math.sin(angle) * distance;

    const sprite = new Particle({
        texture: antTexture,
        width: 1,
        height: 1
    })

    ants.push({
        x,
        y,
        angle: random(TWO_PI),
        hasFood: false,
        nearNest: false,
        nearFood: false,
        sprite: container.addParticle(sprite)
    });
}

// Initialize food texture with random food pixels

const ctx = foodTexture.imageSource.context2D;

ctx.textBaseline = "middle";
ctx.textAlign = "center";
ctx.font = "bold 120px Arial";
ctx.fillStyle = `rgb(${foodColor.red*255}, ${foodColor.green*255}, ${foodColor.blue*255})`;
ctx.fillText("Marshall", 300, 300);

// Pull the changed pixels to the buffer
foodTexture.pullImage()

function checkRemainingFood() {
    remainingFood = 9990
    for (let i = 0; i < foodTexture.imageData.data.length; i += 4) {
        if (foodTexture.imageData.data[i + 3] > 0) {
            remainingFood += 1;
        }
    }
}

function eatFood(ant: Ant) {

    // Check if ant is on food pixel
    const foodPixelColor = foodTexture.get(ant.x, ant.y)
    const isOnFood = foodPixelColor.alpha > 0

    // If the ant is close enough to the food and the food pixel is not transparent
    if (isOnFood && !ant.hasFood) {
        ant.hasFood = true;

        // Rotate 180 degrees to face home
        rotateAnt(ant, PI);

        const newColor = new Color({
            r: foodPixelColor.red,
            g: foodPixelColor.green,
            b: foodPixelColor.blue,
            a: foodPixelColor.alpha - (255 / foodStrength)
        });

        foodTexture.set(ant.x, ant.y, newColor)
    }
}

function rotateAnt(ant: Ant, angle: number) {
    ant.angle += angle;
    ant.angle %= TWO_PI;
    if (ant.angle < 0) {
        ant.angle += TWO_PI;
    }
}

function moveAnt(ant: Ant) {
    // Move forward
    ant.x += Math.cos(ant.angle) * antSpeed;
    ant.y += Math.sin(ant.angle) * antSpeed;

    // Wrap around edges
    if (ant.x < 0) ant.x += canvasSize;
    if (ant.x > canvasSize) ant.x -= canvasSize;
    if (ant.y < 0) ant.y += canvasSize;
    if (ant.y > canvasSize) ant.y -= canvasSize;

    // Randomly change direction
    if (random() < antChangeDirectionChance) {
        rotateAnt(ant, random(-PI / 2, PI / 2));
    }
}

function simulateAnts() {
    // Move forward
    for (const ant of ants) {
        
        ant.nearNest = false;
        ant.nearFood = false;

        // Drop off food
        if (ant.hasFood) {
            moveTowardsNest(ant)
            dropFoodAtNest(ant);
        } else {
            eatFood(ant);
        }

        moveAnt(ant);
        
        // Get current pheromone values and apply to ants
        let pheromoneValue: PheremoneData

        if (!ant.hasFood) {
            pheromoneValue = foodPheremones.getPheromone(ant.x, ant.y);
        } else {
            pheromoneValue = homePheremones.getPheromone(ant.x, ant.y);
        }
        
        // If pheromone value is high, turn towards it, ignore pheremone if they have a target
        if (pheromoneValue.strength > 0.1) {
            let targetAngle = (TWO_PI - pheromoneValue.angle) % TWO_PI; // Invert angle to face the pheromone
            if (targetAngle < 0) {
                targetAngle += TWO_PI;
            }
            ant.angle = lerp(
                ant.angle,
                targetAngle,
                random(antPheremoneDirectionMinStrength, antPheremoneDirectionMaxStrength) // Adjust angle towards pheromone
            ) % TWO_PI;
        }
        
        // Add pheromone trails
        if (ant.hasFood) {
            foodPheremones.addPheromone(ant.x, ant.y, ant.angle);
        } else {
            homePheremones.addPheromone(ant.x, ant.y, ant.angle);
        }

        endSimulation(ant)
    }

}

function dropFoodAtNest(ant: Ant) {
    // Check if the ant is at the nest, assume its at (0, 0)
    if (dist(ant.x, ant.y, nest.x, nest.y) < nest.radius && ant.hasFood) {
        ant.hasFood = false;

        // Rotate 180 degrees to face food source
        rotateAnt(ant, PI);
    }
}

function moveTowardsNest(ant: Ant) {
    const angleToNest = Math.atan2(nest.y - ant.y, nest.x - ant.x);
    ant.angle = lerp(ant.angle, angleToNest, 0.02) % TWO_PI;

    // If the ant is within distance of the nest, it will move towards it
    if (dist(ant.x, ant.y, nest.x, nest.y) > nest.radius + foodDetectionRadius) {
        // Doesn't know where the food is, so it will just wander around
        return;
    }
    ant.nearNest = true;
    // Move towards food
    ant.angle = lerp(ant.angle, angleToNest, 0.2) % TWO_PI;
}

function endSimulation(ant: Ant) {
    if (remainingFood > endSimulationFoodThreshold) {
        return
    }

    const effectStrength = remainingFood / endSimulationFoodThreshold

    // Return ants to nest
    const angleToNest = Math.atan2(nest.y - ant.y, nest.x - ant.x);
    ant.angle = lerp(ant.angle, angleToNest, 0.16 * effectStrength) % TWO_PI;

    // If the ant is at the nest, it will die
    if (dist(ant.x, ant.y, nest.x, nest.y) < nest.radius) {
        // Remove the ant from the array
        const index = ants.indexOf(ant);
        if (index > -1) {
            ants.splice(index, 1);
        }
    }
}

app.ticker.add((time) => {
    if (ants.length === 0) {
        return
    }

    const now = new Date().getTime()

    // If the simulation is running too slow
    if (now - start > 1000) {
        console.log('Simulation is running too slow, skipping frames');
        start = now;
    }

    while (start < now) {
        simulateAnts()
        start += 1000 / simulationSpeed;
    }

    // Push pixel changes to the buffer
    foodTexture.pushImage()

    checkRemainingFood()

    homePheremones.fadePheremones()
    foodPheremones.fadePheremones()

    // Draw all ants
    for (const ant of ants) {
        ant.sprite.x = ant.x
        ant.sprite.y = ant.y
    }
})



</script>