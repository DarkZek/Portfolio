<input type="checkbox" oninput="window.debugging = this.checked" />
<label for="debugging">Debugging</label>

<style lang="scss" is:global>
    #q5Canvas0 {
        border-radius: 300px;
    }
</style>

<script>
import 'q5';
import { Pheremone, type PheremoneData } from './pheremones'

let q
let antOffset: [number, number] = [0, 0]

if ((navigator as any).gpu) {
    q = await Q5.WebGPU()
} else {
    q = await new Q5()
    // WebGL for some reason needs a different ant offset
    antOffset = [300, 300]
}

const canvasSize = 600;
const pheremonesSize = 60;
const antCount = 20_000

const antSpeed = 1.75;
const antChangeDirectionChance = 0.001;
const antPheremoneDirectionMinStrength = 0.01;
const antPheremoneDirectionMaxStrength = 0.03;
const antColor = color(0, 0, 0);

const foodDetectionRadius = 40;
// How many times can one pixel be eaten
const foodStrength = 1;
const foodColor = color(117, 162, 103)
const endSimulationFoodThreshold = 1000

let remainingFood = 1;

createCanvas(canvasSize, canvasSize, {
    alpha: true
})

type Ant = {
    x: number;
    y: number;
    angle: number;
    hasFood: boolean;
    nearNest: boolean;
    nearFood: boolean;
}

const homePheremones = new Pheremone(createImage(pheremonesSize, pheremonesSize, { willReadFrequently: true }), pheremonesSize / canvasSize);

const foodPheremones = new Pheremone(createImage(pheremonesSize, pheremonesSize, { willReadFrequently: true }), pheremonesSize / canvasSize);

const foodTexture = createImage(canvasSize, canvasSize, { willReadFrequently: true })

foodTexture.updatePixels();

const nest = {
    x: 300,
    y: 500,
    radius: 50
}

const ants: Ant[] = []

// Initialize ants
for (let i = 0; i < antCount; i++) {

    // Generate a random position near the nest
    const angle = random(TWO_PI);
    const distance = random(0, nest.radius);
    
    const x = nest.x + Math.cos(angle) * distance;
    const y = nest.y + Math.sin(angle) * distance;

    ants.push({
        x,
        y,
        angle: random(TWO_PI),
        hasFood: false,
        nearNest: false,
        nearFood: false
    });
}

// Initialize food texture with random food pixels
const ctx = foodTexture.ctx;

ctx.textBaseline = "middle";
ctx.textAlign = "center";
ctx.font = "bold 120px Arial";
ctx.fillStyle = `rgb(${foodColor.levels[0]}, ${foodColor.levels[1]}, ${foodColor.levels[2]})`;
ctx.fillText("Marshall", canvasSize / 2, canvasSize / 2);

function checkRemainingFood() {
    remainingFood = 0

    foodTexture.loadPixels();

    for (let i = 0; i < foodTexture.pixels.length; i += 4) {
        if (foodTexture.pixels[i + 3] > 0) {
            remainingFood += 1;
        }
    }
}

function eatFood(ant: Ant) {

    // Check if ant is on food pixel
    const foodPixelColor = foodTexture.get(ant.x, ant.y)
    const isOnFood = foodPixelColor[3] > 0

    // If the ant is close enough to the food and the food pixel is not transparent
    if (isOnFood && !ant.hasFood) {
        ant.hasFood = true;

        // Rotate 180 degrees to face home
        rotateAnt(ant, PI);

        foodTexture.set(ant.x, ant.y, color(255, 255, 255, foodPixelColor[3] - ( 255 / foodStrength ))); // Remove food pixel
    }
}

function rotateAnt(ant: Ant, angle: number) {
    ant.angle += angle;
    ant.angle %= TWO_PI;
    if (ant.angle < 0) {
        ant.angle += TWO_PI;
    }
}

function moveAnt(ant: Ant) {
    // Move forward
    ant.x += Math.cos(ant.angle) * antSpeed;
    ant.y += Math.sin(ant.angle) * antSpeed;

    // Wrap around edges
    if (ant.x < 0) ant.x += width;
    if (ant.x > width) ant.x -= width;
    if (ant.y < 0) ant.y += height;
    if (ant.y > height) ant.y -= height;

    // Randomly change direction
    if (random() < antChangeDirectionChance * deltaTime) {
        rotateAnt(ant, random(-PI / 2, PI / 2));
    }
}

function simulateAnts() {
    // Move forward
    for (const ant of ants) {
        
        ant.nearNest = false;
        ant.nearFood = false;

        // Drop off food
        if (ant.hasFood) {
            moveTowardsNest(ant)
            dropFoodAtNest(ant);
        } else {
            eatFood(ant);
        }

        moveAnt(ant);
        
        // Get current pheromone values and apply to ants
        let pheromoneValue: PheremoneData

        if (!ant.hasFood) {
            pheromoneValue = foodPheremones.getPheromone(ant.x, ant.y);
        } else {
            pheromoneValue = homePheremones.getPheromone(ant.x, ant.y);
        }
        
        // If pheromone value is high, turn towards it, ignore pheremone if they have a target
        if (pheromoneValue.strength > 0.1) {
            let targetAngle = (TWO_PI - pheromoneValue.angle) % TWO_PI; // Invert angle to face the pheromone
            if (targetAngle < 0) {
                targetAngle += TWO_PI;
            }
            ant.angle = lerp(
                ant.angle,
                targetAngle,
                random(antPheremoneDirectionMinStrength, antPheremoneDirectionMaxStrength) * deltaTime // Adjust angle towards pheromone
            ) % TWO_PI;
        }
        
        // Add pheromone trails
        if (ant.hasFood) {
            foodPheremones.addPheromone(ant.x, ant.y, ant.angle);
        } else {
            homePheremones.addPheromone(ant.x, ant.y, ant.angle);
        }

        endSimulation(ant)
    }

}

function dropFoodAtNest(ant: Ant) {
    // Check if the ant is at the nest, assume its at (0, 0)
    if (dist(ant.x, ant.y, nest.x, nest.y) < nest.radius && ant.hasFood) {
        ant.hasFood = false;

        // Rotate 180 degrees to face food source
        rotateAnt(ant, PI);
    }
}

function moveTowardsNest(ant: Ant) {
    const angleToNest = Math.atan2(nest.y - ant.y, nest.x - ant.x);
    ant.angle = lerp(ant.angle, angleToNest, 0.02) % TWO_PI;

    // If the ant is within distance of the nest, it will move towards it
    if (dist(ant.x, ant.y, nest.x, nest.y) > nest.radius + foodDetectionRadius) {
        // Doesn't know where the food is, so it will just wander around
        return;
    }
    ant.nearNest = true;
    // Move towards food
    ant.angle = lerp(ant.angle, angleToNest, 0.2) % TWO_PI;
}

function endSimulation(ant: Ant) {
    if (remainingFood > endSimulationFoodThreshold) {
        return
    }

    const effectStrength = remainingFood / endSimulationFoodThreshold

    // Return ants to nest
    const angleToNest = Math.atan2(nest.y - ant.y, nest.x - ant.x);
    ant.angle = lerp(ant.angle, angleToNest, 0.16 * effectStrength) % TWO_PI;

    // If the ant is at the nest, it will die
    if (dist(ant.x, ant.y, nest.x, nest.y) < nest.radius) {
        // Remove the ant from the array
        const index = ants.indexOf(ant);
        if (index > -1) {
            ants.splice(index, 1);
        }
    }
}

q.draw = () => {
    if (ants.length === 0) {
        return
    }

    clear()

    noStroke()

    simulateAnts()

    // Zero the canvas
    translate(-canvasSize/2, -canvasSize/2);

    homePheremones.image.updatePixels()
    foodPheremones.image.updatePixels()
    foodTexture.updatePixels();

    checkRemainingFood()

    if ((window as any).debugging) {
        background(foodPheremones.image);
    }

    background(foodTexture)

    homePheremones.fadePheremones()
    foodPheremones.fadePheremones()

    noStroke()

    // Draw all ants
    fill(antColor);
    for (const ant of ants) {
        ellipse(ant.x + antOffset[0], ant.y + antOffset[1], 1, 1);
    }

    // Zero the canvas
    translate(canvasSize/2, canvasSize/2);
}


</script>